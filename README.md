# 内存管理 - 请求页式管理模拟

操作系统第二次课程作业 - 请求页式管理模拟

Table of Contents
=================

   * [内存管理 - 请求页式管理模拟](#内存管理---请求页式管理模拟)
      * [项目需求](#项目需求)
         * [基本任务](#基本任务)
         * [功能描述](#功能描述)
         * [项目目的](#项目目的)
      * [开发环境](#开发环境)
      * [操作说明](#操作说明)
      * [系统分析](#系统分析)
         * [置换算法](#置换算法)
            * [LRU算法](#lru算法)
            * [FIFO算法](#fifo算法)
            * [LFU算法](#lfu算法)
            * [OPT算法](#opt算法)
            * [CLOCK算法](#clock算法)
         * [执行模式](#执行模式)
            * [320条指令产生方式](#320条指令产生方式)
      * [实验小结](#实验小结)
         * [实验结果对比](#实验结果对比)
         * [分析](#分析)
      * [作者](#作者)
-----
## 项目需求

### 基本任务

假设每个页面可存放10条指令，分配给一个作业的内存块为4。模拟一个作业的执行过程，该作业有320条指令，即它的地址空间为32页，目前所有页还没有调入内存。

### 功能描述

- 在模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令；如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存。如果4个内存块中已装入作业，则需进行页面置换。
- 所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率。

- 置换算法可以选用FIFO或者LRU算法

- 作业中指令访问次序可以按照下面原则形成：  

  ​    50%的指令是顺序执行的，25%是均匀分布在前地址部分，25％是均匀分布在后地址部分

### 项目目的

- 页面、页表、地址转换
- 页面置换过程
- 加深对请求调页系统的原理和实现过程的理解。



## 开发环境

- **开发环境:** MBP

- **开发软件:** 

  **Visual Studio Code** 

- **开发语言:** html,css,js

- **引用模块：**vue elementUI

## 操作说明

- 选择页面置换算法
- 点击init/init2按钮
- 点击start按钮
- 观察结果，再选择新的页面置换算法
- 直至5种置换算法全部选择完，比较5种算法的效果

<img src="/Users/fanqing_m/Library/Application Support/typora-user-images/image-20210611083806610.png" alt="image-20210611083806610" style="zoom:50%;" />

首先选择页面置换算法，之后点击下图的INIT/INIT2按钮，最后点击start，可以在下图的表中看到相应的指令序列是如何调入内存块中的。并且可以在上图结果统计分析中看到选择的对应算法的缺页率等指标信息

对于这个表，有以下几点信息

- Sequence：序号，从1顺序到320

- Instruction：指令的标号，范围是0-319，通过标号区别不同指令

- Frame：四块内存块

  - 当某一内存块空时，其内部值为-1

  - 当某一内存块非空时，其内部值是存储页的页号（在本项目中，为指令标号/10）

    - 比如在下图中，标号213的指令需要进入内存，通过调度算法选择Frame1进入，所以将该指令所在的页的页号（213/10）

      21调入Frame1中，Frame1的值就为21.

<img src="/Users/fanqing_m/Library/Application Support/typora-user-images/image-20210611083919819.png" alt="image-20210611083919819" style="zoom:50%;" />


## 系统分析

### 	置换算法

#### 		LRU算法

- **当前页面已经在内存中** => 不需要进行调度
- 当**内存中存在内存块空闲**时 => 直接将页面顺序加入到内存的空闲块中
- 当**内存满**时 => 每次替换掉最近最少使用的内存块中的页面
  - 维护一个大小为4的res数组
  - 维护已执行指令序列所对应的页号序列
  - 当需要替换时，res中第i个值是第i个内存块中目前的页号从当前向初始进行遍历，第一次出现的时刻（这里的时刻指的是其在页号序列中的序号）
  - 寻找res中最小的值所对应的下标
  - 需要进行页面置换的内存块的下标就是上一步中找到的下标

#### 		FIFO算法

- **当前页面已经在内存中** => 不需要进行调度
- 当**内存中存在空闲块**时 => 直接将页面顺序加入到内存的空闲块中
- 当**内存满**时 => 每次一次替换掉内存块中最先进来的页面
  - 维护一个大小为4队列
  - 执行指令就插入队列
  - 取队列末尾元素所在的内存块进行替换

#### 		LFU算法

- **当前页面已经在内存中** => 不需要进行调度

- 当**内存中存在空闲块**时 => 直接将页面顺序加入到内存的空闲块中

- 当**内存满**时 => 每次一次替换掉内存块中最先进来的页面

  - 记录到当前为止每个页号的访问次数数组

  - 选择到当前时间为止被访问次数最少的页面被置换；

  - 发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。

  - 选择该页所在的内存块，替换该内存块中的页

    

#### 		OPT算法

**由于这里是事先按要求生成指令序列，所以可以用OPT算法来计算最佳情况，需要注意的是，实际情况下由于指令序列的不可预知，是无法采用OPT算法的**

- **当前页面已经在内存中** => 不需要进行调度
- 当**内存中存在空闲块**时 => 直接将页面顺序加入到内存的空闲块中

- 当**内存满**时 => 每次一次替换掉内存块中离当前最远位置上出现的页面
  - 初始化指令序列数组
  - 当需要发生页面置换时，记录4个内存块中的当前页号
  - 在指令序列中寻找四个页号中，谁第一次出现的位置距离当前最远
  - 选择该页号所在的内存块进行页面置换

#### 		

#### 		CLOCK算法

- **当前页面已经在内存中** => 不需要进行调度
- 当**内存中存在空闲块**时 => 直接将页面顺序加入到内存的空闲块中
- 当**内存满**时 => 按clock算法寻找需要进行页面置换的内存块进行置换
  - 对于每个页添加标志位，并维护标志位数组
  - 维护pointer指针，初始指向0（即第一个内存块），当页面调入内存时，页面即调入pointer所指的内存块，之后pointer指向下一个位置（如果原来在末尾，则循环到0，即第一个内存块）
  - 当页面调入内存块时，同时将该标志位置为1
  - 当需要进行页面置换时，如果pointer所指的内存块里的页面的标志位是1，就将其标志位改为0，并向下循环遍历，重复之前操作，知道pointer所指的内存块里的页面的标志位为0，停止
  - 选择pointer所指的内存块进行页面置换

#### 		

### 	执行模式

#### 		320条指令产生方式

为了保证320 条指令能够随机产生，并且能够均匀分布，采用了下面这种循环产生指令的方式：

- 在0－319条指令之间，随机选取一个起始执行指令，如序号为m

- 顺序执行下一条指令，即序号为m+1的指令

- 通过随机数，跳转到前地址部分0－m-1中的某个指令处，其序号为m1

- 顺序执行下一条指令，即序号为m1+1的指令

- 通过随机数，跳转到后地址部分m1+2~319中的某条指令处，其序号为m2

- 顺序执行下一条指令，即m2+1处的指令。

重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完320条指令。





## 实验小结

通过本次实验，我充分理解了操作系统中内存管理的原理以及页面调度的具体实现过程，对FIFO 和LRU ，CLOCK等五种调页算法有了更深刻的理解。



### 	实验结果对比

![](/Users/fanqing_m/Library/Application Support/typora-user-images/image-20210611092953280.png)

### 	分析

​	在本次项目中，我使用自己编写的程序，进行了多次实验，并且每次实验均使用了五种调页算法，以比对两种调页算法的效率，但是多次实验之后，我的数据显示除了OPT算法之外的调页算法中的缺页率一致或者相差极小的情况出现了很多次，我尝试着对所取的指令顺序在自己进行两种调页方式的部分模拟，发现两种调页算法并没有出错。经过思考，我认为是指令选取算法的问题，虽然我的指令选取算法保证了指令的分布范围能够比较平均，但是，因为指令的总数目过多，选取的指令很少能够抖动现象，当抖动现象出现的次数极少或者根本不出现时，两种调页算法的效率基本是无差别的。

​	但是经过大量的实验记录，我发现了以下规律

- LRU的缺页率比FIFO低
- CLOCK的缺页率与LRU类似，比FIFO低
- LFU的缺页率比LRU略高
- OPT作为理想情况，每次都是当前指令序列发生最小缺页次数的情况

对于以上规律，确实相对符合OS课程中所讲的观点，结合我自己的思考给出以下分析

- 对于FIFO算法，其先来先走未免有些粗暴，所以采用LRU算法，用过去的情况预知未来的情况，即选择最近最少使用的页面进行置换，相对而言比FIFO更合理，其缺页率也更低
- 考虑到LRU需要单独的硬件支持，实际情况下常用LFU进行替代。但是这实际上也是一种折中方案，因为LFU是选择迄今为止，出现次数最少的页进行置换，但是这一页可能开始不怎么出现，但是在近期出现频繁，根据LRU的理论，很可能在未来也是出现频繁的，所以相对于LRU其算法的效率较低。
  - 但是实际情况下，由于硬件开销常用LFU，本项目中未体现硬件开销

- CLOCK算法是LRU的近似，FIFO的优化，缺页率近似为LRU，但比其稍差；比FIFO好

​	



## 作者

​	**学号**				1950679 

​	**姓名**				孟繁青

​	**指导老师**		张惠娟老师

​	**上课时间**		周三/周五 上午一二节

​	**联系方式**		*email:* 1950679@tongji.edu.cn

​	**Github **


